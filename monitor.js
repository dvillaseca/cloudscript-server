const argv = require('minimist')(process.argv.slice(2));
const compiler = require('./src/compilers/devCompiler.js');
const minifiedCompiler = require('./src/compilers/localReleaseCompiler.js');
const fs = require('fs');
const { spawn } = require('child_process');
const path = require('path');
const chokidar = require('chokidar');
const typesGenerator = require('./typesGenerator.js');
const compilerUtils = require('./src/compilers/compilerUtils.js');
require('colors');
let timeout = null;
let child = null;
let directory = null;

function stopServer() {
    if (child == null)
        return;
    console.log("🛑 Stopping server\n".red);
    child.kill('SIGINT');
    child = null;
}
function startServer() {
    timeout = null;

    stopServer();


    if (argv["clear-cache"] || argv.clearCache) {
        try {
            typesGenerator.clearCache();
            compilerUtils.clearCache();
            console.log("🧹 Cache cleared\n".yellow);
        } catch (error) {
            console.error("❌ Failed to clear cache:\n".red, error);
        }
    }

    try {
        console.log("⚙️  Compiling...".blue);
        const startTime = Date.now();
        if (argv.minify) minifiedCompiler.compile(directory);
        else compiler.compile(directory);
        console.log(`✔️  Compiled in ${Date.now() - startTime}ms`.blue);
    } catch (err) {
        console.error("❌ Failed to compile:\n".red, err);
        return; // do not restart server if compilation failed
    }

    try {
        if (argv['auto-generate-typings'] || argv['autogenerate-typings']) {
            console.log();
            typesGenerator.generateTypings(directory);
        }
    } catch (err) {
        console.error("❌ Failed to generate typings:\n".red, err);
        return;
    }

    let port = argv.p ?? argv.port ?? 8080;
    let serverType = argv._.includes('remote') ? 'server-remote.js' : 'server.js';
    let args = [path.join(__dirname, serverType), port, directory, '--color'];
    if (argv.verbose) args.push('--verbose');
    if (argv.minify) args.push('--minify');
    child = spawn(process.execPath, args, {
        detached: true,
        stdio: 'pipe'
    });
    child.stdout.pipe(process.stdout);
    child.stderr.pipe(process.stderr);
}
function keepAliveChild() {
    if (child == null)
        return;
    child.stdin.write('1', (err) => { });
}
async function main() {
    directory = argv.dir ?? argv.d;
    if (directory != null && !path.isAbsolute(directory)) {
        directory = path.join(process.cwd(), directory);
    }
    else if (directory == null) {
        directory = process.cwd();
    }


    if (argv._.includes("clear-cache")) {
        typesGenerator.clearCache();
        compilerUtils.clearCache();
        console.log("🧹 Cache cleared".green);
        return;
    }

    if (argv._.includes("init")) {
        require('./src/projectInitializer/initializeProject.js')(directory);
        return;
    }

    if (argv._.includes(`generate-typings`)) {
        require('./typesGenerator.js').generateTypings(directory);
        return;
    }

    if (argv._.includes('typings')) {
        require('./types-generator.js')(directory);
        return;
    }
    if (argv._.includes('publish')) {
        await require('./publisher.js')(directory);
        return;
    }

    console.log(("📂 Monitoring folder: " + directory.bold.underline + "\n").yellow);

    chokidar.watch(directory, {
        ignored: [
            /node_modules/,
            /typings[\/\\]autogenerated[\/\\]/
        ],
        ignoreInitial: true
    })
        .on('all', (event, filePath) => {
            let extension = path.extname(filePath);
            if (extension != '.js' && extension != '.ts' && !filePath.includes('.env'))
                return;
            if (timeout != null) {
                clearTimeout(timeout);
            }
            timeout = setTimeout(startServer, 500);
        });

    process.on('SIGINT', () => {
        stopServer();
        process.exit();
    });
    process.on('exit', stopServer);
    startServer();
    setInterval(keepAliveChild, 5000);
}
main();